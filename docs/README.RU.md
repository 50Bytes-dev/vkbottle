## Инструкции по посадке

Установка и другие первоэтапные действия описаны в [README.md](/README.md)

Нужные нам классы:

```python
from vkbottle import Bot, Message, keyboard_gen, VKError
```

## Переменные первой ступени:

`session` - aiohttp ClientSession  
`plugin_folder` - строка, название папки бота для хранения логов  
`patcher` -  bot patching class, нужен для валидаторов, whitelistа и подобного  
`on` - хендлеры тут
`api` - VK Api враппер

## Callback!

Мы можем создать простой обработчик событий фласком

```
# app = FrameWork()
@app.route('/')
async def route():
    return await bot.emulate(request.args(), confirmation_token='YourConfirm')
```

Это решение помогает сохранять совместимость с процессом совмещения держания бота и сайта на одном адресе

**:cowboy_hat_face: При Callback'е поллинг запускать не надо..**

## Декораторы

### Простой ответ на сообщение:

:star: В личные сообщения:

```python
@bot.on.message(text='привет')
async def wrapper(ans: Message):
    await ans('Ну привет!')
```

:star: В чат:

```python
@bot.on.message_chat(text='привет')
async def wrapper(ans: Message):
    await ans('Ну привет (всем)!')
```

### Message - ans

Message - простой типизационный датакласс, так же с ним доступны методы:  

`__call__` - простой вызов для написания сообщения в уже сохраненный диалог  
`reply` - ответ на сообщение с уже сохраненным id сообщения

### События

```python
@bot.on.event.group_join()
async def wrapper(event: GroupJoin):
    print('+1')
```

### Класс декоратора сообщения

Вы можете использовать startswith и regex:

Startswith:

```python
@bot.on.message.startswith(text='привет')
async def wrapper(ans: Message):
    await ans('твое сообщение началось с <<привет>>')
```

Regex:

```python
@bot.on.message_chat.regex('.*?')
async def wrapper(ans: Message):
    await ans('этот декоратор сработает при каждом сообщении из чата (зач?)')
```

Вы можете использовать параметр lower для того чтобы игнорировать кейс написания сообщения.  
Вы можете использовать параметр command для того чтобы не писать префикс в начале команды, по умолчанию префикс это - `/`  
Для того чтобы назначить несколько префиксов добавьте `bot.on.change_prefix_for_all(list_prefixes)`, например:
```python
bot.on.change_prefix_for_all(['!', '/'])
```
Теперь обработчик считает за префикс команды сообщения начинающиеся с `!` и `/`

### Кнопки

Чтобы make кнопки в вашем сообщении just примените генератор или будьте уродами и не используйте его:

1) Составим паттерн:
   Наш список должен состоять из рядов с кнопками:  
   
   ```python
   pattern = [[{'text': 'моя кнопка'}]]
   ```
   
   Вместе с `text` можно передавать все параметры доступные для кнопок из официальной документации

2) Создадим клавиатуру

```python
my_keyboard = keyboard_gen(pattern, one_time=False)
```

3) Отправим ее

```python
@bot.on.message(text='клавиатуру пожалуйста', lower=True)
async def wrapper(ans: Message):
    await ans('держите', keyboard=keyboard)
```

### Другие декораторы

**@bot.on.chat_mention()**  
Срабатывает при чистом упоминании бота в чате

**@bot.on.chat_invite()**  
Срабатывает при добавлении бота в чат

Кстати, реакции на сообщения работают при упоминании бота в чате через @ 

### :heartpulse: Аргументы хендлеров

```python
@bot.on.message('меня зовут <name>')
async def wrapper(ans: Message, name):
    await ans(f'Ну привет, {name}!')
```

Это работает во всем кроме regex декоратора, но вы можете решить это, если знаете regexp и загляните в vbml_parser  

### Валидаторы

Есть отдельная документация по валидаторам на русском языке, [загляните сюда](/docs/validators-docs.md).  
Валидаторы используются в основном для поддержания бота в тонусе и минимизации нагрузки. Валидаторы позволяют вам не проверять является ли какая-то часть сообщения числом или ссылкой, все это встроено. Кроме того вы можете писать свои собственные кастомные валидаторы.

### Бранчи (аналог FSM)

Бранчи, так называемые short-term ветки событий, с помощью них вы можете постоить систему тестов, ввод какого-то значения пользователем или даже ~~игрового бота~~
Документацию по бранчам вы сможете найти [перейдя сюда](/docs/branches.ru.md)
