# Применение валидаторов

Валидаторы - штуки, контроллирующие прохождения аргументов под шаблон сообщения. Давайте напишем простую обработку сообщения с простым аргументом

```python
@bot.on.message_handler(text='мне <some> лет', lower=True)
async def wrapper(ans: Message, some: typing.Any):
    await ans(f'Все ясно! @id{ans.from_id} (этому человеку) {some} лет')
```

Теперь реакция бота на сообщения шаблона `мне 5 лет` будет указанным сообщением. Но вот проблема! Мы не можем контроллировать вхождение аргумента, точнее мы можем, но только применяя условие с проверкой на `isdigit()` и какими-то другими заморочками.

**Валидаторы!** Вот то что нам нужно. С помощью них мы сможем контроллировать вхождения аргументов по определенным условиям с помощью встроенного в модуль патчера (`VKBottle Patcher v0.2`)  и собственного языка разметки основанного на regex - VBML (VKBottle Marking Language).

### Изучаем аргументы сообщений с точки зрения VBML

VBML - простой язык разметки на regex, то что нам нужно ведь в него встроена валидация для аргументов.

Для того присвоить аргументу валидатор нужно указать его после названия аргумента, например так:

`<some:validator>`

Проверьте работу VBML прямо сейчас. Создайте обработчик с указанным кодом прямо сейчас:

```python
@bot.on.message_handler(text='<some:validator>', lower=True, command=True)
async def wrapper(ans: Message, some: typing.Any):
    await ans(f'Введена команда {some}!')
```

Теперь при итерировании этого обработчика `some` будет проверяться по валидатору `validator`.

Этот самый `validator` является тестовым валидатором и просто скажет вам о том, что все работает правильно, а именно валидация VBML.

**Вы можете использовать несколько валидаторов, даже одинаковых сразу**

`<some:validator:validator2>`

### Создание собственных валидаторов

Главной фишкой валидаторов является не использование трех стандартных, а создание собственных. Я хочу учесть кое-какую особенность, пользуясь этим свойством патчера.

Давайте создадим кастомный класс собственных валидаторов, наследуя стандартный класс `PatchedValidators`:

```python
from vbml import PatchedValidators, Patcher

class MyValidators(PatchedValidators):
    pass

patcher = Patcher(validators=MyValidators)
# bot = Bot(...)
```

Теперь мы можем создавать собственные валидаторы. При создании валидаторов вам нужно придеживаться нескольких правил оформления:

* Фунции должны быть методами класса (не staticmethod) и содержать один аргумент, который будет принимать валидируемый аргумент

* Аргумент будет считаться правильным если валидатор вернет все что угодно кроме `None`.

* Не `None` возвращение валидатора и будет возвращаться в хендлер

Я собираюсь учесть проблему, где, благодаря трудностям славянских языков для указания возраста мы можем использовать и `лет`, и `года`, и `год`

```python
class MyValidators(PatchedValidators):
    def years(self, text: str):
        if text in ['лет', 'года', 'год']:
            return text
        return  # https://docs.python.org/3.7/reference/simple_stmts.html#the-return-statement
```

Теперь напишу конечный обработчик:

```python
@bot.on.message_handler(text='мне <years:int> <y_rep:years>', lower=True)
async def wrapper(ans: Message, years: int, y_rep: str):
    if years >= 18:
        await ans(f'Ого тебе уже {years} {y_rep}')
    else: 
        await ans(f'Эм тебе еще только {years} {y_rep}')
```

Ура!

## Аргументы валидаторов

Создам простой валидатор startswith для аргументов, для этого в класс MyValidators добавлю новый обработчик:  

```python
def startswith(self, value: str, start: str):
    if value.startswith(start):
        return value
```

Теперь я могу использовать этот валидатор:

```python
@bot.on.message_handler(text='президент <name:startswith[Ким]>', lower=True)
async def wrapper(ans: Message, name: str):
    assert name.startswith("Ким")
    await ans(f'Да да! Президент {name}.')
```

* Аргументов может быть много, они перечисляются через запятую без пробелов.  
* Если аргумент цифра - он автоматически в нее конвертируется.
* Стандартный тип аргумента `int`.